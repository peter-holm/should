TODO for 1.0.-4:
* review and test dirsync mechanism
* review and test event filtering
* should.conf(5) manpage
* improve the check whether a file needs to be copied during dirsync by
  using the event we've already created from get_local_dir()
* config - parse_command and assign_command to allow quoting and spaces
* copy - timed / periodic dirsync as per dirsync_interval / dirsync_timed
* server - IGNORE command and EXTENSION
* copy - multi-master mode, connects to a local server as well as a remote
  one, and uses IGNORE on the local server before doing any file operation as
  a result of replication from the remote server.
* client / should.1 - copy modify: for example "should modify=FILE new_options"
* client / should.1 - copy display: for example "should display=FILE"
* server: if disallow_unix removes the last user, need to make the socket
  accessible by the owner only (if then allow_unix adds a user again, it
  can give the socket more permissions). This is only important during
  config_commit_update. Or maybe we just prohibit removing the last user.
* [dis]allow_local as synonyms for [dis]allow_unix
* review and test initscripts
* try to avoid the poll() in store_get as it seems to slow things down

Possible future improvements:
* a nicer interface to the "should" configuration
* link encryption (ENCRYPT command and EXTENSION, etc).
* rewrite config.c to use a table instead of the huge switch(); the
  table could also be used to print the current configuration.
* rewrite control thread to use a table instead of the huge switch();
  the table could also contain a bitmap of which modes allow which
  command, and produce a helpful message if a command is recognised
  but not supported.
* lzo compression
* lzma compression
* generate locale files with the error messages instead (or in addition to)
  of reading them from config
* split out client code to a client library to connect/do things/etc, which
  encapsulates the protocol and just offers library calls. Modify client.c
  and Should::Client to use this library.
* extend allow_unix and allow_tcp to be able to restrict what operations the
  user can perform and (for allow_tcp) from which host; for example:
  allow_unix=user:copy,status,stop
  allow_tcp=user:pass:copy,status,host=192.168.1.0/24,host=2001:12:34::0/48
  the options would be one or more of copy, status(+watches), stop, add,
  remove, rotate(=closelog), getconfig, setconfig, as well as host=range
  (repeating host= would mean any of the ones listed)
* maybe the control thread could provide periodic stats (if enabled in config)
* "should remove" could also remove the parent watch (etc) if its only subdir
  has just been removed
* "should remove" could also do with a "find" parameter
* Add a config parameter to increase fs:inotify:max_user_watches and
  fs:inotify:max_queued_events on startup, possibly automatically tweaking
  them somehow if possible and limits are about to be reached.
* monitor fs:inotify:max_user_watches and fs:inotify:max_queued_events and
  possibly autoincrease them depending on configurable limits
* allow to dynamically load "store" methods if not predefined in
  store_thread.c:store_init()
* Change should to create a real process (with fork rather than
  pthread_create) after parsing config, and have the child creating all the
  threads, while the parent just waits for the child, removes the socket and
  exits with the child's status. Do this only if a socket is going to be
  created.
* [i]exclude_event[_glob] -- does filtering at the event level rather than at
  the watch level.
* if a new dir is created which happens to be in a different fs, this will
  be automatically watched even if "nocross" was specified on the watch.
  Also, this automatic watch does not check excludes.

